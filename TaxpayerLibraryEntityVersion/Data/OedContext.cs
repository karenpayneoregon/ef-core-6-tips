// <auto-generated> This file has been auto generated by EF Core Power Tools. </auto-generated>
using ConfigurationLibrary.Classes;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using TaxpayerLibraryEntityVersion.Classes;
using TaxpayerLibraryEntityVersion.Converters;
using TaxpayerLibraryEntityVersion.Models;
#nullable disable

namespace TaxpayerLibraryEntityVersion.Data;

public partial class OedContext : DbContext
{
    public OedContext()
    {
        ChangeTracker.StateChanged += UpdateTimestamps;
        ChangeTracker.Tracked += UpdateTimestamps;
    }

    public OedContext(DbContextOptions<OedContext> options) : base(options)
    {
    }

    public virtual DbSet<Taxpayer> Taxpayer { get; set; }
    public virtual DbSet<Category> Categories { get; set; }
    
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            optionsBuilder.UseSqlServer(ConfigurationHelper.ConnectionString());
        }
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfiguration(new Configurations.TaxpayerConfiguration());

        OnModelCreatingPartial(modelBuilder);
    }

    partial void OnModelCreatingPartial(ModelBuilder modelBuilder);

    /// <summary>
    /// This method sets up all <see cref="DateOnly"/> properties to have
    /// a conversion to and from <see cref="DateTime"/> as in the <see cref="Taxpayer"/>
    /// table one column is date.
    /// </summary>
    /// <param name="builder"></param>
    protected override void ConfigureConventions(ModelConfigurationBuilder builder)
    {

        builder.Properties<DateOnly>()
            .HaveConversion<DateOnlyConverter>()
            .HaveColumnType("date");

        base.ConfigureConventions(builder);

    }

    /// <summary>
    /// Used to timestamp actions
    /// </summary>
    private static void UpdateTimestamps(object sender, EntityEntryEventArgs e)
    {
        if (e.Entry.Entity is IHasTimestamps entityWithTimestamps)
        {
            switch (e.Entry.State)
            {
                case EntityState.Deleted:
                    entityWithTimestamps.DeletedOn = DateTime.UtcNow;
                    break;
                case EntityState.Modified:
                    entityWithTimestamps.Modified = DateTime.UtcNow;
                    break;
                case EntityState.Added:
                    entityWithTimestamps.Added = DateTime.UtcNow;
                    break;
            }
        }
    }

    /// <summary>
    /// Handles soft deletes
    /// </summary>
    /// <returns>Affected count</returns>
    /// <remarks>
    /// This code (other than the return statement) can be placed into another
    /// method e.g. BeforeSave then override the async version of SaveChangesAsync
    /// </remarks>
    public override int SaveChanges()
    {
        PerformSoftDeleteActions();
        return base.SaveChanges();
    }

    public override Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = new CancellationToken())
    {
        PerformSoftDeleteActions();
        return base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
    }

    private void PerformSoftDeleteActions()
    {
        var deletedEntityEntries = ChangeTracker
            .Entries()
            .Where(item => 
                item.Entity is ISoftDelete && item.State == EntityState.Deleted)
            .ToList();

        foreach (var itemEntityEntry in deletedEntityEntries)
        {
            ((ISoftDelete)itemEntityEntry.Entity).IsDeleted = true;
            itemEntityEntry.State = EntityState.Modified;
        }
    }
}